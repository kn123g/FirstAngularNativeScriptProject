import { EventEmitter, Component, ElementRef, Inject, ViewContainerRef, Output, Input, Directive, NgModule } from '@angular/core';
import { registerElement } from '@nativescript/angular';
import { RadSideDrawer } from 'nativescript-ui-sidedrawer';

/// <reference path="references.d.ts" />
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
const TKDRAWERCONTENT = "TKDrawerContent";
const TKMAINCONTENT = "TKMainContent";
/**
* This is the SideDrawer component. It separates your mobile app's screen
* into a main part and a menu part whereby the menu part is shown upon a swipe
* gesture using a transition effect.
*/
class RadSideDrawerComponent {
    constructor(elementRef, viewContainer) {
        this.elementRef = elementRef;
        this.viewContainer = viewContainer;
        this.drawerOpening = new EventEmitter();
        this.drawerOpen = new EventEmitter();
        this.drawerClosing = new EventEmitter();
        this.drawerClosed = new EventEmitter();
        this.sideDrawer = this.elementRef.nativeElement;
    }
    /**
      * [Deprecated: Please use the 'drawerTransition' property instead].
      */
    set transition(transition) {
        this.sideDrawer.drawerTransition = transition;
    }
    get nativeElement() {
        return this.sideDrawer;
    }
    /**
      * Defines either the width or the height
      * of the menu pane depending on the location of the SideDrawer.
      * Top or Bottom - height, Right or Left - width.
      */
    set drawerContentSize(value) {
        this._drawerContentSize = value;
        this.updateContentSize();
    }
    set gesturesEnabled(value) {
        this._gesturesEnabled = value;
        this.updateGesturesEnabled();
    }
    set drawerTransition(value) {
        this._drawerTransition = value;
        this.updateDrawerTransition();
    }
    set drawerLocation(value) {
        this._drawerLocation = value;
        this.updateDrawerLocation();
    }
    updateDrawerLocation() {
        this.sideDrawer.drawerLocation = this._drawerLocation;
    }
    updateDrawerTransition() {
        this.sideDrawer.drawerTransition = this._drawerTransition;
    }
    updateGesturesEnabled() {
        this.sideDrawer.gesturesEnabled = this._gesturesEnabled;
    }
    updateContentSize() {
        this.sideDrawer.drawerContentSize = this._drawerContentSize;
    }
}
RadSideDrawerComponent.ɵfac = function RadSideDrawerComponent_Factory(t) { return new (t || RadSideDrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(ViewContainerRef)); };
RadSideDrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RadSideDrawerComponent, selectors: [["RadSideDrawer"]], inputs: { transition: "transition" }, outputs: { drawerOpening: "drawerOpening", drawerOpen: "drawerOpen", drawerClosing: "drawerClosing", drawerClosed: "drawerClosed" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function RadSideDrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
RadSideDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: ViewContainerRef, decorators: [{ type: Inject, args: [ViewContainerRef,] }] }
];
RadSideDrawerComponent.propDecorators = {
    drawerOpening: [{ type: Output }],
    drawerOpen: [{ type: Output }],
    drawerClosing: [{ type: Output }],
    drawerClosed: [{ type: Output }],
    transition: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RadSideDrawerComponent, [{
        type: Component,
        args: [{
                selector: 'RadSideDrawer',
                template: "<ng-content></ng-content>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: ɵngcc0.ViewContainerRef, decorators: [{
                type: Inject,
                args: [ViewContainerRef]
            }] }]; }, { drawerOpening: [{
            type: Output
        }], drawerOpen: [{
            type: Output
        }], drawerClosing: [{
            type: Output
        }], drawerClosed: [{
            type: Output
        }], transition: [{
            type: Input
        }] }); })();
/**
 * Directive identifying the drawer content.
 */
class TKDrawerContentDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._elementRef.nativeElement.id = TKDRAWERCONTENT;
    }
}
TKDrawerContentDirective.ɵfac = function TKDrawerContentDirective_Factory(t) { return new (t || TKDrawerContentDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); };
TKDrawerContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TKDrawerContentDirective, selectors: [["", "tkDrawerContent", ""]] });
TKDrawerContentDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TKDrawerContentDirective, [{
        type: Directive,
        args: [{
                selector: "[tkDrawerContent]"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }]; }, null); })();
/**
 * Directive identifying the main content.
 */
class TKMainContentDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._elementRef.nativeElement.id = TKMAINCONTENT;
    }
}
TKMainContentDirective.ɵfac = function TKMainContentDirective_Factory(t) { return new (t || TKMainContentDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef)); };
TKMainContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TKMainContentDirective, selectors: [["", "tkMainContent", ""]] });
TKMainContentDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TKMainContentDirective, [{
        type: Directive,
        args: [{
                selector: "[tkMainContent]"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }]; }, null); })();
const ɵ0 = (parent, child) => {
    const drawer = parent;
    const childView = child;
    if (childView.id === TKMAINCONTENT) {
        drawer.mainContent = childView;
    }
    if (childView.id === TKDRAWERCONTENT) {
        drawer.drawerContent = childView;
    }
}, ɵ1 = (parent, child) => {
    const drawer = parent;
    const childView = child;
    if (childView.id === TKMAINCONTENT) {
        drawer.mainContent = null;
    }
    if (childView.id === TKDRAWERCONTENT) {
        drawer.drawerContent = null;
    }
};
let sideDrawerMeta = {
    insertChild: ɵ0,
    removeChild: ɵ1,
};
/**
 * Directives identifying the RadSideDrawer.
 */
const SIDEDRAWER_DIRECTIVES = [RadSideDrawerComponent, TKDrawerContentDirective, TKMainContentDirective];
registerElement("RadSideDrawer", () => RadSideDrawer, sideDrawerMeta);
/**
 * NgModule containing all of the RadSideDrawer directives.
 */
class NativeScriptUISideDrawerModule {
}
NativeScriptUISideDrawerModule.ɵfac = function NativeScriptUISideDrawerModule_Factory(t) { return new (t || NativeScriptUISideDrawerModule)(); };
NativeScriptUISideDrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NativeScriptUISideDrawerModule });
NativeScriptUISideDrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NativeScriptUISideDrawerModule, { declarations: [RadSideDrawerComponent, TKDrawerContentDirective, TKMainContentDirective], exports: [RadSideDrawerComponent, TKDrawerContentDirective, TKMainContentDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NativeScriptUISideDrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [SIDEDRAWER_DIRECTIVES],
                exports: [SIDEDRAWER_DIRECTIVES]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NativeScriptUISideDrawerModule, RadSideDrawerComponent, SIDEDRAWER_DIRECTIVES, TKDrawerContentDirective, TKMainContentDirective, ɵ0, ɵ1 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlc2NyaXB0LXVpLXNpZGVkcmF3ZXItYW5ndWxhci5qcyIsInNvdXJjZXMiOlsibmF0aXZlc2NyaXB0LXVpLXNpZGVkcmF3ZXItYW5ndWxhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs2QkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt1SUFLRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpSUFLRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdCwgVmlld0NvbnRhaW5lclJlZiwgT3V0cHV0LCBJbnB1dCwgRGlyZWN0aXZlLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgcmVnaXN0ZXJFbGVtZW50IH0gZnJvbSAnQG5hdGl2ZXNjcmlwdC9hbmd1bGFyJztcbmltcG9ydCB7IFJhZFNpZGVEcmF3ZXIgfSBmcm9tICduYXRpdmVzY3JpcHQtdWktc2lkZWRyYXdlcic7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJyZWZlcmVuY2VzLmQudHNcIiAvPlxuY29uc3QgVEtEUkFXRVJDT05URU5UID0gXCJUS0RyYXdlckNvbnRlbnRcIjtcbmNvbnN0IFRLTUFJTkNPTlRFTlQgPSBcIlRLTWFpbkNvbnRlbnRcIjtcbi8qKlxuKiBUaGlzIGlzIHRoZSBTaWRlRHJhd2VyIGNvbXBvbmVudC4gSXQgc2VwYXJhdGVzIHlvdXIgbW9iaWxlIGFwcCdzIHNjcmVlblxuKiBpbnRvIGEgbWFpbiBwYXJ0IGFuZCBhIG1lbnUgcGFydCB3aGVyZWJ5IHRoZSBtZW51IHBhcnQgaXMgc2hvd24gdXBvbiBhIHN3aXBlXG4qIGdlc3R1cmUgdXNpbmcgYSB0cmFuc2l0aW9uIGVmZmVjdC5cbiovXG5jbGFzcyBSYWRTaWRlRHJhd2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCB2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuZHJhd2VyT3BlbmluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kcmF3ZXJPcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRyYXdlckNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZHJhd2VyQ2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNpZGVEcmF3ZXIgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIFtEZXByZWNhdGVkOiBQbGVhc2UgdXNlIHRoZSAnZHJhd2VyVHJhbnNpdGlvbicgcHJvcGVydHkgaW5zdGVhZF0uXG4gICAgICAqL1xuICAgIHNldCB0cmFuc2l0aW9uKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5zaWRlRHJhd2VyLmRyYXdlclRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIH1cbiAgICBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lkZURyYXdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIERlZmluZXMgZWl0aGVyIHRoZSB3aWR0aCBvciB0aGUgaGVpZ2h0XG4gICAgICAqIG9mIHRoZSBtZW51IHBhbmUgZGVwZW5kaW5nIG9uIHRoZSBsb2NhdGlvbiBvZiB0aGUgU2lkZURyYXdlci5cbiAgICAgICogVG9wIG9yIEJvdHRvbSAtIGhlaWdodCwgUmlnaHQgb3IgTGVmdCAtIHdpZHRoLlxuICAgICAgKi9cbiAgICBzZXQgZHJhd2VyQ29udGVudFNpemUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZHJhd2VyQ29udGVudFNpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVDb250ZW50U2l6ZSgpO1xuICAgIH1cbiAgICBzZXQgZ2VzdHVyZXNFbmFibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVzRW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlc3R1cmVzRW5hYmxlZCgpO1xuICAgIH1cbiAgICBzZXQgZHJhd2VyVHJhbnNpdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kcmF3ZXJUcmFuc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlRHJhd2VyVHJhbnNpdGlvbigpO1xuICAgIH1cbiAgICBzZXQgZHJhd2VyTG9jYXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZHJhd2VyTG9jYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVEcmF3ZXJMb2NhdGlvbigpO1xuICAgIH1cbiAgICB1cGRhdGVEcmF3ZXJMb2NhdGlvbigpIHtcbiAgICAgICAgdGhpcy5zaWRlRHJhd2VyLmRyYXdlckxvY2F0aW9uID0gdGhpcy5fZHJhd2VyTG9jYXRpb247XG4gICAgfVxuICAgIHVwZGF0ZURyYXdlclRyYW5zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuc2lkZURyYXdlci5kcmF3ZXJUcmFuc2l0aW9uID0gdGhpcy5fZHJhd2VyVHJhbnNpdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlR2VzdHVyZXNFbmFibGVkKCkge1xuICAgICAgICB0aGlzLnNpZGVEcmF3ZXIuZ2VzdHVyZXNFbmFibGVkID0gdGhpcy5fZ2VzdHVyZXNFbmFibGVkO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5zaWRlRHJhd2VyLmRyYXdlckNvbnRlbnRTaXplID0gdGhpcy5fZHJhd2VyQ29udGVudFNpemU7XG4gICAgfVxufVxuUmFkU2lkZURyYXdlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnUmFkU2lkZURyYXdlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiXG4gICAgICAgICAgICB9LF0gfVxuXTtcblJhZFNpZGVEcmF3ZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtFbGVtZW50UmVmLF0gfV0gfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW1ZpZXdDb250YWluZXJSZWYsXSB9XSB9XG5dO1xuUmFkU2lkZURyYXdlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkcmF3ZXJPcGVuaW5nOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgZHJhd2VyT3BlbjogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGRyYXdlckNsb3Npbmc6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBkcmF3ZXJDbG9zZWQ6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB0cmFuc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbi8qKlxuICogRGlyZWN0aXZlIGlkZW50aWZ5aW5nIHRoZSBkcmF3ZXIgY29udGVudC5cbiAqL1xuY2xhc3MgVEtEcmF3ZXJDb250ZW50RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5pZCA9IFRLRFJBV0VSQ09OVEVOVDtcbiAgICB9XG59XG5US0RyYXdlckNvbnRlbnREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJbdGtEcmF3ZXJDb250ZW50XVwiXG4gICAgICAgICAgICB9LF0gfVxuXTtcblRLRHJhd2VyQ29udGVudERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0VsZW1lbnRSZWYsXSB9XSB9XG5dO1xuLyoqXG4gKiBEaXJlY3RpdmUgaWRlbnRpZnlpbmcgdGhlIG1haW4gY29udGVudC5cbiAqL1xuY2xhc3MgVEtNYWluQ29udGVudERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaWQgPSBUS01BSU5DT05URU5UO1xuICAgIH1cbn1cblRLTWFpbkNvbnRlbnREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJbdGtNYWluQ29udGVudF1cIlxuICAgICAgICAgICAgfSxdIH1cbl07XG5US01haW5Db250ZW50RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbRWxlbWVudFJlZixdIH1dIH1cbl07XG5jb25zdCDJtTAgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgIGNvbnN0IGRyYXdlciA9IHBhcmVudDtcbiAgICBjb25zdCBjaGlsZFZpZXcgPSBjaGlsZDtcbiAgICBpZiAoY2hpbGRWaWV3LmlkID09PSBUS01BSU5DT05URU5UKSB7XG4gICAgICAgIGRyYXdlci5tYWluQ29udGVudCA9IGNoaWxkVmlldztcbiAgICB9XG4gICAgaWYgKGNoaWxkVmlldy5pZCA9PT0gVEtEUkFXRVJDT05URU5UKSB7XG4gICAgICAgIGRyYXdlci5kcmF3ZXJDb250ZW50ID0gY2hpbGRWaWV3O1xuICAgIH1cbn0sIMm1MSA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgY29uc3QgZHJhd2VyID0gcGFyZW50O1xuICAgIGNvbnN0IGNoaWxkVmlldyA9IGNoaWxkO1xuICAgIGlmIChjaGlsZFZpZXcuaWQgPT09IFRLTUFJTkNPTlRFTlQpIHtcbiAgICAgICAgZHJhd2VyLm1haW5Db250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNoaWxkVmlldy5pZCA9PT0gVEtEUkFXRVJDT05URU5UKSB7XG4gICAgICAgIGRyYXdlci5kcmF3ZXJDb250ZW50ID0gbnVsbDtcbiAgICB9XG59O1xubGV0IHNpZGVEcmF3ZXJNZXRhID0ge1xuICAgIGluc2VydENoaWxkOiDJtTAsXG4gICAgcmVtb3ZlQ2hpbGQ6IMm1MSxcbn07XG4vKipcbiAqIERpcmVjdGl2ZXMgaWRlbnRpZnlpbmcgdGhlIFJhZFNpZGVEcmF3ZXIuXG4gKi9cbmNvbnN0IFNJREVEUkFXRVJfRElSRUNUSVZFUyA9IFtSYWRTaWRlRHJhd2VyQ29tcG9uZW50LCBUS0RyYXdlckNvbnRlbnREaXJlY3RpdmUsIFRLTWFpbkNvbnRlbnREaXJlY3RpdmVdO1xucmVnaXN0ZXJFbGVtZW50KFwiUmFkU2lkZURyYXdlclwiLCAoKSA9PiBSYWRTaWRlRHJhd2VyLCBzaWRlRHJhd2VyTWV0YSk7XG4vKipcbiAqIE5nTW9kdWxlIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBSYWRTaWRlRHJhd2VyIGRpcmVjdGl2ZXMuXG4gKi9cbmNsYXNzIE5hdGl2ZVNjcmlwdFVJU2lkZURyYXdlck1vZHVsZSB7XG59XG5OYXRpdmVTY3JpcHRVSVNpZGVEcmF3ZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1NJREVEUkFXRVJfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1NJREVEUkFXRVJfRElSRUNUSVZFU11cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IE5hdGl2ZVNjcmlwdFVJU2lkZURyYXdlck1vZHVsZSwgUmFkU2lkZURyYXdlckNvbXBvbmVudCwgU0lERURSQVdFUl9ESVJFQ1RJVkVTLCBUS0RyYXdlckNvbnRlbnREaXJlY3RpdmUsIFRLTWFpbkNvbnRlbnREaXJlY3RpdmUsIMm1MCwgybUxIH07XG4iXX0=